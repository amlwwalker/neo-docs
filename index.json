[{"uri":"http://example.org/introduction/","title":"Introduction","tags":[],"description":"","content":"NeoFS Concepts This chapter outlines the concepts and top level points required to understand and enjoy building on NeoFS\n"},{"uri":"http://example.org/examples/","title":"Examples","tags":[],"description":"","content":"Code examples Examples of building the different elements required to communicate effectively with NeoFS\n"},{"uri":"http://example.org/","title":"Neo FS Tutorias","tags":[],"description":"","content":""},{"uri":"http://example.org/examples/objects/","title":"Objects","tags":[],"description":"","content":"Objects represent items stored within a container. These are subject to the permissions of the container being the most relaxed possible permissions that can be applied to an object. It is possilbe using Session/Bearer Tokens to restrict permissions further on objects within a container however\nPlease note actions on objects are restricted by the permissions on the container AND the permissions of the token used to access the functions.\nUploading Objects Before uploading an object, you will need\n A session Token A container ID to upload the object to, with the correct permisisions An object to upload (filepath) Have created a client (cli)  Attributes Attributes are key value pairs (string:string) that are attached to the metadata of objects. You can specify anything as an attribute, however there are a couple of reserved ones\nvar attributes []*object2.Attribute timeStampAttr := new(object.Attribute) timeStampAttr.SetKey(object.AttributeTimestamp) // AttributeTimestamp key is like a \u0026#39;created at\u0026#39; attribute timeStampAttr.SetValue(strconv.FormatInt(time.Now().Unix(), 10)) fileNameAttr := new(object.Attribute) fileNameAttr.SetKey(object.AttributeFileName) // AttributeFileName key is the filename to be associated with the object. This will become useful later fileNameAttr.SetValue(path.Base(filepath)) attributes = append(attributes, []*object2.Attribute{timeStampAttr, fileNameAttr}...) See tokens for how to create a session token\nUpload f, err := os.Open(filepath) defer f.Close() if err != nil { return \u0026#34;\u0026#34;, err } reader := bufio.NewReader(f) var ioReader io.Reader ioReader = reader ownerID, err := wallet.OwnerIDFromPrivateKey(key) if err != nil { return \u0026#34;\u0026#34;, err } cntId := new(cid.ID) cntId.Parse(containerID) id, err := object.UploadObject(ctx, cli, cntId, ownerID, attributes, sessionToken, \u0026amp;ioReader) if err != nil { return fmt.Println(\u0026#34;error attempting to upload\u0026#34;, err) } return id.String(), err //id is the object ID that you will want to reference Depending on your container\u0026rsquo;s permissions you should now be able to view the file you uploaded at:\nhttps://http.testnet.fs.neo.org/CONTAINER_ID/OBJECT_ID\nhowever, if you set the\nfileNameAttr := new(object.Attribute) fileNameAttr.SetKey(object.AttributeFileName) // AttributeFileName key is the filename to be associated with the object. This will become useful later fileNameAttr.SetValue(path.Base(filepath)) attribute, you can also refer to the object by its filename, i.e\nhttps://http.testnet.fs.neo.org/CONTAINER_ID/upload.png\nNote path.Base(filepath) will give you back just the filename part of a filepath:\nfilepath := /users/bond/home/upload.png filename := path.Base(filepath) //filename = upload.png Listing the content of a container Once you have uploaded objects to a container, you will want to list them out. Listing is a special case of searching within a container. To search for specific objects, you add filters to the search. By setting the only filter as a root filter, it will list everything within the container\nvar searchParams = new (client.SearchObjectParams) var filters = object.SearchFilters{} filters.AddRootFilter() searchParams.WithContainerID(containerID) searchParams.WithSearchFilters(filters) res, err := cli.SearchObjects(ctx, searchParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) } fmt.Printf(\u0026#34;list objects %+v\\n\u0026#34;, res.IDList()) Retrieve an Object Once you have the ID of an object, you can download it.\nYou will need\n an io.Writer to write the data to a file such as a file writer an object address, which is made up of a container ID and an object ID  To generate an object address from the string forms of a containerID and an objectID:\ncontID := cid.New() contID.Parse(containerID) objID := obj.NewID() objID.Parse(objectID) objAddress := obj.NewAddress() objAddress.SetObjectID(objID) objAddress.SetContainerID(contID) so now you can retrieve the object\nvar getParams = new(client.GetObjectParams) getParams.WithAddress(objectAddress) getParams.WithPayloadWriter(*writer) o, err := cli.GetObject(ctx, getParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) } // payload is in bytes []bytes payload := o.Object().Payload() } Retrieving an objects HEAD/metadata Sometimes you want information about an object, without actually downloading the entire object, for instance the size of an object\nFrom a container, you can find out storage policies, owners and any other meta information about the container itself. This is very similar to retrieving the object\nvar headParams = new(client.ObjectHeaderParams) headParams.WithAddress(objectAddress) headObject, err := cli.HeadObject(ctx, headParams, client.WithSession(sessionToken)) if err != nil { return \u0026amp;client.ObjectHeadRes{}, err } size := headObject.Object().PayloadSize() Deleting Objects You may wish to delete an object for a container\nvar deleteParams = new (client.DeleteObjectParams) deleteParams.WithAddress(objectAddress) _, err := cli.DeleteObject(ctx, deleteParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) } Questions about objects  Can you update the attributes of an existing object Can you determine the original uploader of an object  "},{"uri":"http://example.org/examples/tokens/","title":"Tokens","tags":[],"description":"","content":"Tokens are requried to act on any objects within a container. Sessions last for limited time and are restricted by permissions. Session tokens use the private key to sign them while bearer tokens are issued to wallets by a container owner.\nSession Tokens Session tokens are tokens that are generated from your private key and are required to access or interact with content inside a container (depending on permissions this can include READ capability). These tokens should only be used by container owners and not distributed to third parties\nCreating a token You will need\n to decide how long the token should last (shorter is better) a context (generally you can use context.Background()) but this depends on your usecase A client (see client) Your private key, available from your wallet/account  sessionResponse, err := cli.CreateSession(ctx, expiration) if err != nil { return \u0026amp;session.Token{}, err } st := session.NewToken() id, err := wallet.OwnerIDFromPrivateKey(key) if err != nil { return \u0026amp;session.Token{}, err } st.SetOwnerID(id) st.SetID(sessionResponse.ID()) st.SetSessionKey(sessionResponse.SessionKey()) //st is your new session token  "},{"uri":"http://example.org/examples/clients/","title":"Clients","tags":[],"description":"","content":"There are two types of client to be aware, of and as they are both clients, it can be confusing. You have a wallet client and an NeoFS client. Interactions with NeoFS will require a NeoFS client, whereas wallet actions will require a wallet client. Note they do not reside in the same package\nWallet Client When using a wallet client you will import\nimport ( \u0026#34;github.com/nspcc-dev/neo-go/pkg/rpc/client\u0026#34; \u0026#34;github.com/nspcc-dev/neo-go/pkg/wallet\u0026#34;\t) To create a wallet client\nctx := context.Background() // use endpoint addresses of public RPC nodes, e.g. from https://dora.coz.io/monitor cli, err := client.New(ctx, \u0026#34;http://seed1t4.neo.org:20332\u0026#34;, client.Options{}) if err != nil { return util.Uint256{}, err } NeoFS Client The client wraps around the raw API requests to NeoFS. Once you have a client requests to NeoFS can be made so you will need to make this early on from the wallet/private key.\nWhen using the NeoFS client you will import\nimport ( \u0026#34;github.com/nspcc-dev/neofs-sdk-go/client\u0026#34; ) Creating a client can be done like so\ncli, err := client.New( // provide private key associated with request owner  client.WithDefaultPrivateKey(privateKey), // find endpoints in https://testcdn.fs.neo.org/doc/integrations/endpoints/  client.WithURIAddress(TESTNET, nil), // check client errors in go compatible way  client.WithNeoFSErrorParsing(), ) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create client: %w\u0026#34;, err) }  Private key can be retrieved from a wallet - its type is *ecdsa.PrivateKey The network is a string, for now you can use  TESTNET string = \u0026#34;grpcs://st01.testnet.fs.neo.org:8082\u0026#34; MAINNET = \u0026#34;grpcs://st01.testnet.fs.neo.org:8082\u0026#34; "},{"uri":"http://example.org/examples/policies/","title":"Policies","tags":[],"description":"","content":"Before we can create a container, we need to define the policy. A policy defines which storage nodes on NeoFS you are happy to store your data on.\n\u0026ndash; todo, how do policies get defined?\nBasic example\nREP 2 IN X CBF 2 SELECT 2 FROM * AS X "},{"uri":"http://example.org/examples/wallets/","title":"Wallets","tags":[],"description":"","content":"Almost everything you may want to do with NeoFS will require access to a wallet. Here are a few handy ways to get a wallet\nimport ( \u0026#34;github.com/nspcc-dev/neo-go/pkg/rpc/client\u0026#34; \u0026#34;github.com/nspcc-dev/neo-go/pkg/wallet\u0026#34;\t) Retrieve from a NEP-6 file (json format) w, err := wallet.NewWalletFromFile(path) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t read the wallet: %w\u0026#34;, err) } Create a new wallet This wallet has no password but is the simplest form of wallet that you can generate\nacc, err := wallet.NewAccount() //generates a new private key if err != nil { return \u0026amp;wallet.Wallet{}, err } w, err := wallet.NewWallet(path) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create the wallet: %w\u0026#34;, err) } w.AddAccount(acc) A slighty more secure wallet\u0026hellip; with a password w, err := wallet.NewWallet(path) w.CreateAccount(name, password) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create the wallet: %w\u0026#34;, err) } Retrieving the private key from a wallet Sometimes for specific actions you will need the private key of the wallet. If you have the password you can extract the private key\nNotice this decrypts the wallet. At this point the wallet is considered \u0026ldquo;unlocked\u0026rdquo;. Sometimes you may find you are performing an action on a walelt and the error is it is locked. The result of decrypting is unlocking the wallet.\naddr := w.GetChangeAddress() //get the default wallet acc := w.GetAccount(addr) if acc == nil { return nil, fmt.Errorf(\u0026#34;invalid wallet address %s: %w\u0026#34;, addrStr, err) } if err := acc.Decrypt(password, keys.NEP2ScryptParams()); err != nil { return nil, errors.New(\u0026#34;[decrypt] invalid password - \u0026#34; + err.Error()) } privateKey := \u0026amp;acc.PrivateKey().PrivateKey Retrieving wallet balances Often you will want to know the balances on a wallet. There is a potential minor confusion at this stage. Neo N3 wallets store NEP-17 coins. Both Neo and Gas are NEP 17 currencies, however any currency you or someone else may make could also be a NEP-17 currency. There are other standards such as NEP-11 and the difference I will leave to you to read about.\nHowever, NeoFS has a smart contract in which you need to transfer Gas to, so that you can pay for NeoFS storage space. This balance won\u0026rsquo;t show up in your wallet balance.\nTo retrieve you wallet\u0026rsquo;s NEP-17 balances you will need to create a wallet client.\nYou will need\n A wallet address you want to get the balances of  cli, err := client.New(ctx, \u0026#34;http://seed1t4.neo.org:20332\u0026#34;, client.Options{}) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create the client: %w\u0026#34;, err) } err = cli.Init() if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t init the client: %w\u0026#34;, err) } recipient, err := StringToUint160(walletAddress) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t convert the wallet address: %w\u0026#34;, err) } balances, err := cli.GetNEP17Balances(recipient) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t retrieve the balances: %w\u0026#34;, err) } fmt.Printf(\u0026#34;balances %+v\\r\\n\u0026#34;, balances) helper function for above\n// StringToUint160 attempts to decode the given NEO address string // into an Uint160. const NEO3Prefix byte = 0x35 func StringToUint160(s string) (u util.Uint160, err error) { b, err := base58.CheckDecode(s) if err != nil { return u, err } if b[0] != NEO3Prefix { return u, errors.New(\u0026#34;wrong address prefix\u0026#34;) } return util.Uint160DecodeBytesBE(b[1:21]) } Transferring NEP-17 tokens A major part of blockchain technology is to be able to transfer tokens to other wallets (including sending GAS to the NeoFS smart contract).\nYou will need\n An unlocked wallet myWallet A wallet to send Nep17 to walletTo The amount you would like to send (as an int64 - no decimals in blockchain remember!) The token you would like to send. To retrieve the token, you need the token name to get the contract hash  gasToken, err := cli.GetNativeContractHash(nativenames.Gas) if err != nil { log.Fatal(err) } then\nctx := context.Background() // use endpoint addresses of public RPC nodes, e.g. from https://dora.coz.io/monitor cli, err := client.New(ctx, \u0026#34;http://seed1t4.neo.org:20332\u0026#34;, client.Options{}) if err != nil { return util.Uint256{}, err } err = cli.Init() if err != nil { return util.Uint256{}, err } recipient, err := StringToUint160(walletTo) if err != nil { return util.Uint256{}, err } txHash, err := cli.TransferNEP17(myWallet, recipient, gasToken, amount, 0, nil, nil) le := txHash.StringLE() return txHash, err NOTE the txHash is reversed in its uint256 state. You need to reverse it so that it matches the txHashes you would find in a blockchain explorer for instance, hence the le := txHash.StringLE()\nNeoFS Balance However this balance as I mentioned, does not include your NeoFS balance. For that you need a NeoFS client\nimport ( \u0026#34;github.com/nspcc-dev/neofs-sdk-go/client\u0026#34; ) Once you have this, you can now retrieve your NeoFS balance\nYou will need\n Private key NeoFS client (cli)  w, err := owner.NEO3WalletFromPublicKey(\u0026amp;key.PublicKey) if err != nil { fmt.Errorf(\u0026#34;couldn\u0026#39;t create wallet from public key: %w\u0026#34;, err) } id := owner.NewIDFromNeo3Wallet(w) ctx := context.Background() neoFSBalance, err := m.fsCli.GetBalance(ctx, id) fmt.Printf(\u0026#34;neofs balance %+v\\r\\n\u0026#34;, neoFSBalance) "},{"uri":"http://example.org/introduction/libraries/","title":"Libraries","tags":[],"description":"","content":"Code Libraries The Go SDK is the basis of all the functionality that is available to you as a developer with regards to NeoFS. Due to the underlying protocol of NeoFS being gRPC, this can be ported to other languages (coming soon here) however for the time being, to get started it is best to use the Go SDK.\nThere are however certain \u0026lsquo;functionalities\u0026rsquo; that you will require from the Neo-Go library (such as wallet management and cryptography packages), which you can read more about here.\nSDK The SDK is responsible for providing functionality to interact with NeoFS itself via gRPC requests. You will need the SDK for such things as:\n creating, retrieving, deleting containers creating, updating, retrieving, deleting objects permissions  Neo-Go library General interaction with NeoFS doesn\u0026rsquo;t require Neo-Go however invariably you will need to manage wallets or use cryptographic functions that are required while setting permissions throughout the NeoFS system.\n"},{"uri":"http://example.org/examples/containers/","title":"Containers","tags":[],"description":"","content":"Containers manage the permissions/access of a group of objects that are being stored. Before being able to store an object, you need to create a container.\nCreating a container Before being able to create a container, you will need to\n create a policy (placementPolicy) have access to a wallet (key) Decide on a set of permissions, (permissions) Have created a client (cli)  Owner ID You will need to get the owner ID from the wallet private key. The owner ID is not the same as the wallet ID or public key. A straight forward way to do this is\n//see key retrieval generation for how to get a key w, err := owner.NEO3WalletFromPublicKey(\u0026amp;key.PublicKey) if err != nil { return fmt.Errorf(\u0026#34;invalid private key\u0026#34;) } ownerID := owner.NewIDFromNeo3Wallet(w) Now we can get on with creating a container\ncontainerPolicy, err := policy.Parse(placementPolicy) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t parse placement policy: %w\u0026#34;, err) } cnr := container.New( // container policy defines the way objects will be  // placed among storage nodes from the network map  container.WithPolicy(containerPolicy), // container owner can set BasicACL and remove container  container.WithOwnerID(ownerID), // read more about basic ACL in specification:  // https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/07-acl.md  container.WithCustomBasicACL(permissions), // Attributes are key:value string pairs they are always optional  container.WithAttribute( container.AttributeTimestamp, strconv.FormatInt(time.Now().Unix(), 10), ), Finally we can put the container on NeoFS. We will receive a response that contains the container\u0026rsquo;s ID.\nresponse, err := cli.PutContainer(ctx, cnr) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t put container: %w\u0026#34;, err) } fmt.Println(response.ID()) Listing Containers You can list all the containers owned by a wallet. This will return an array of container IDs\nresponse, err := cli.ListContainers(ctx, wallet.OwnerIDFromPrivateKey(key)) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t list container: %w\u0026#34;, err) } walletList := response.IDList() Retrieve a Container You can retrieve a container once you have the ID\nresponse, err := cli.GetContainer(ctx, containerID) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t get container %s: %w\u0026#34;, containerID, err) } contianeer := response.Container() From a container, you can find out storage policies, owners and any other meta information about the container itself\nDeleting Containers Once you have created a container, you will receive the ID of the container as part of the response (see above). Using this ID you can now delete the container with ease\nresponse, err := cli.DeleteContainer(ctx, containerID) if err != nil { return nil, fmt.Errorf(\u0026#34;can\u0026#39;t get container %s: %w\u0026#34;, containerID, err) } fmt.Printf(\u0026#34;deletion response %+v\\r\\n\u0026#34;, response) Questions about containers  if you delete a container what happens to all the objects within a container using multisig wallets, could two or more people share ownership of a container status - what information do I receive from a status?  "},{"uri":"http://example.org/introduction/concepts/","title":"Concepts","tags":[],"description":"","content":"NeoFS is very carefully designed to offer the power of a filesytem with all the expected capabilities, on top of a decentralised network.\nThis means that files/folders etc can have permissions to who can read/write to them who can delete etc etc.\nAs NeoFS is built on top of the Neo blockchain, these permissions are based on wallet addresses of users.\nObjects Objects represent all files/data that is stored on NeoFS. Objects are accessed via SessionTokens or Bearer Tokens\nContainers A container controls the basic permissions that are applied to all content within it. Think of a container like a drive on a computer or network (and not a folder per se).\nAll objects must live within a container, their permissions will default to the permissions of the container\nOwnerID OwnerID is derived from the private key of a wallet and is unique to that wallet.\nPolicies Container policies define the way objects will be placed among storage nodes. That is, you as the container owner can decide what type of Node should store a file for you.\nEACL Containers and sessions/bearer tokens can have differeing permissions. By default permissions will be the same as the container\u0026rsquo;s however if permissions are sent as part of a request, then they can override the permissions of the container\nRead more about ACL here\nAccess Access is made using session tokens (derived from the private key), or bearer tokens, which are distributed by the container owner to others they want to be able to offer restricted capabilities (and time limits) to other users\nWallets A wallet is specifically an item that takes the NEP-6 format and contains any number of accounts. Accounts contain a public address, a private key and other information (read more here)\n"},{"uri":"http://example.org/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://example.org/tags/","title":"Tags","tags":[],"description":"","content":""}]