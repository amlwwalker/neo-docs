[{"uri":"https://amlwwalker.github.io/neo-docs/introduction/","title":"Introduction","tags":[],"description":"","content":"Introduction This chapter covers information surrounding the use of Neo and NeoFS in Go\n"},{"uri":"https://amlwwalker.github.io/neo-docs/introduction/overview/","title":"Overview","tags":[],"description":"","content":"Concepts This chapter outlines the concepts and top level points required to understand and enjoy building on neo \u0026amp; NeoFS\nStarting out You will need:\n Go language installed and running Clone, or go get the libraries outlined below. Confirm you can import them into a project Read the wallets page as it will outline the basis of working with Neo and NeoFS - a wallet. Neo/Gas in your wallet. You can get these from the testnet faucet here These libraries will assume you are using the testnet throughout. All urls referenced can be retrieved from NeoFS or from Dora the explorer.  Libraries Libraries covers the packages and libraries that are required to interact with Neo and NeoFS in Go\nReferences  neofs-spec  With Thanks To  NSPCC team - team behind NeoFS, the neo-go-sdk and the neo-go packages  "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/","title":"Tutorials","tags":[],"description":"","content":"Code Tutorials Tutorials on the concepts of Neo and NeoFS and building with the different elements that are available to build on Neo and NeoFS\n"},{"uri":"https://amlwwalker.github.io/neo-docs/","title":"","tags":[],"description":"","content":"Neo Community Documentation Currently this is very much a work in progress, however I hope that with time this documentation will help developers realise the immense apps that they can build on top of Neo.\nPlease join us on the Neo discord server if you would like any support and please contribute back if you have something to add!\nWith time there will be an easy to use \u0026lsquo;get things done\u0026rsquo; API for Go, and a starter app for Javascript developers to build on top of.\nBest place to get started is probably in the overview area, or if you want to get cracking, head over the creating a wallet!\n "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/objects/","title":"Objects","tags":[],"description":"","content":"Objects represent items stored within a container. These are subject to the permissions of the container being the most relaxed possible permissions that can be applied to an object. It is possible using Session/Bearer Tokens to restrict permissions further on objects within a container however\nPlease note actions on objects are restricted by the permissions on the container AND the permissions of the token used to access the functions.\nUploading Objects Before uploading an object, you will need\n A session token A container ID to upload the object to, with the correct permissions An object to upload (filepath) Have created a NeoFS client (cli)  Attributes Attributes are key value pairs (string:string) that are attached to the metadata of objects. You can specify anything as an attribute, however there are a couple of reserved ones Go Python C#  var attributes []*object.Attribute timeStampAttr := new(object.Attribute) timeStampAttr.SetKey(object.AttributeTimestamp) // AttributeTimestamp key is like a \u0026#39;created at\u0026#39; attribute timeStampAttr.SetValue(strconv.FormatInt(time.Now().Unix(), 10)) fileNameAttr := new(object.Attribute) fileNameAttr.SetKey(object.AttributeFileName) // AttributeFileName key is the filename to be associated with the object. fileNameAttr.SetValue(path.Base(filepath)) //path.Base(filepath) returns the last element of a file path (usually the filename)  expirationEpochAttr := new(object.Attribute) expirationEpochAttr.SetKey(object.AttributeFileName) // AttributeFileName key is the filename to be associated with the object. expirationEpochAttr.SetValue(path.Base(filepath)) //path.Base(filepath) returns the last element of a file path (usually the filename)  attributes = append(attributes, []*object.Attribute{timeStampAttr, fileNameAttr}...)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     If you have set the FileName attribute, you can also refer to the object by its filename, i.e https://http.testnet.fs.neo.org/CONTAINER_ID/upload.png when its uploaded, (see acl permissions)\n Session Token See tokens for how to create a session token\nUpload Go Python C#  f, err := os.Open(filepath) defer f.Close() if err != nil { return fmt.Println(\u0026#34;couldn\u0026#39;t open the file\u0026#34;, err) } reader := bufio.NewReader(f) var ioReader io.Reader ioReader = reader ownerID, err := wallet.OwnerIDFromPrivateKey(key) if err != nil { return fmt.Println(\u0026#34;couldn\u0026#39;t retrieve owner ID\u0026#34;, err) } cntId := new(cid.ID) cntId.Parse(containerID) id, err := object.UploadObject(ctx, cli, cntId, ownerID, attributes, sessionToken, \u0026amp;ioReader) if err != nil { return fmt.Println(\u0026#34;error attempting to upload\u0026#34;, err) } return id.String(), err //id is the object ID that you will want to reference    print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Depending on your container\u0026rsquo;s permissions you should now be able to view the file you uploaded at:\nhttps://http.testnet.fs.neo.org/CONTAINER_ID/OBJECT_ID\nGo Python C#  fileNameAttr := new(object.Attribute) fileNameAttr.SetKey(object.AttributeFileName) // AttributeFileName key is the filename to be associated with the object. fileNameAttr.SetValue(path.Base(filepath)) //path.Base(filepath) returns the filename from a filepath   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Listing the content of a container Once you have uploaded objects to a container, you will want to list them out. Listing is a special case of searching within a container. To search for specific objects, you add filters to the search. By setting the only filter as a root filter, it will list everything within the container Go Python C#  var searchParams = new (client.SearchObjectParams) var filters = object.SearchFilters{} filters.AddRootFilter() searchParams.WithContainerID(containerID) searchParams.WithSearchFilters(filters) res, err := cli.SearchObjects(ctx, searchParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) } fmt.Printf(\u0026#34;list objects %+v\\n\u0026#34;, res.IDList())   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Retrieve an Object Once you have the ID of an object, you can download it.\nYou will need\n an io.Writer to write the data to a file such as a file writer an object address, which is made up of a container ID and an object ID  To generate an object address from the string forms of a containerID and an objectID: Go Python C#  contID := cid.New() contID.Parse(containerID) objID := obj.NewID() objID.Parse(objectID) objAddress := obj.NewAddress() objAddress.SetObjectID(objID) objAddress.SetContainerID(contID)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     so now you can retrieve the object Go Python C#  var getParams = new(client.GetObjectParams) getParams.WithAddress(objectAddress) getParams.WithPayloadWriter(*writer) o, err := cli.GetObject(ctx, getParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) } // payload is in bytes []bytes payload := o.Object().Payload() }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Retrieving an objects HEAD/metadata Sometimes you want information about an object, without actually downloading the entire object, for instance the size of an object\nFrom a container, you can find out storage policies, owners and any other meta information about the container itself. This is very similar to retrieving the object\nGo Python C#  var headParams = new(client.ObjectHeaderParams) headParams.WithAddress(objectAddress) headObject, err := cli.HeadObject(ctx, headParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) } size := headObject.Object().PayloadSize()   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Deleting Objects You may wish to delete an object for a container\nGo Python C#  var deleteParams = new (client.DeleteObjectParams) deleteParams.WithAddress(objectAddress) _, err := cli.DeleteObject(ctx, deleteParams, client.WithSession(sessionToken)) if err != nil { return fmt.Errorf(err) }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Questions about objects  Can you update the attributes of an existing object Can you determine the original uploader of an object  "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/tokens/","title":"Tokens","tags":[],"description":"","content":"Tokens are requried to act on any objects within a container. Sessions last for limited time and are restricted by permissions. Session tokens use the private key to sign them while [bearer tokens(/examples/tokens) are issued to wallets by a container owner.\nSession Tokens Session tokens are tokens that are generated from your private key and are required to access or interact with content inside a container. These tokens should only be used by container owners and not distributed to third parties\nCreating a session token You will need\n to decide how long the token should last (e.g const DEFAULT_EXPIRATION = 140000) a context (generally you can use context.Background()) but this depends on your usecase A NeoFS client have access to a private key. This is retrieved from a json file using the helper function helper.GetCredentialsFromPath (key)  Go Python C#  sessionResponse, err := cli.CreateSession(ctx, DEFAULT_EXPIRATION) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create session: %w\u0026#34;, err) } st := session.NewToken() id, err := wallet.OwnerIDFromPrivateKey(key) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t get owner ID: %w\u0026#34;, err) } st.SetOwnerID(id) st.SetID(sessionResponse.ID()) st.SetSessionKey(sessionResponse.SessionKey()) //st is your new session token    print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Session tokens are all that is required for the owner, or the account with the private key that created the container, to access the container. The owner is the most privileged account with regards to a container so a session key should never be shared.\nBearer Tokens Bearer tokens allow the account that owns the container, to issue limited time access tokens to other accounts. Bearer tokens require rules to be applied to grant access and to deny access to anyone else. Read more about EACL Tables to get a better understanding of what they are\nOnce an account has a bearer token it can pass the token along with any request to the container as it does a Session Token.\nYou will need\n A NeoFS client A context (context.Background is fine in most cicumstances) When you want the bearer token to expire, in epochs. See helpers for a basic estimation The ownerID of the intended account (see helpers) (tokenReceiverOwnerID) An EACL table The container owner\u0026rsquo;s private key (containerOwnerPrivateKey)  info, err := GetNetworkInfo(ctx, cli) //info retrieves latest block information from the blockchain \tlt := new(acl.TokenLifetime) lt.SetExp(helper.CalculateEpochsForTime(info.CurrentEpoch(), duration, info.MsPerBlock())) //set the token lifetime. \t//bt.SetLifetime(lt.GetExp(), lt.GetNbf(), lt.GetIat()) \tbtoken := new(token.BearerToken) btoken.SetOwner(tokenReceiverOwnerID) //btoken.SetLifetime(expiry, 10, 1) // exp, nbf, iat arguments like in JWT \tbtoken.SetLifetime(lt.GetExp(), lt.GetNbf(), lt.GetIat()) // exp, nbf, iat arguments like in JWT \tbtoken.SetEACLTable(eaclTable) err = btoken.SignToken(containerOwnerPrivateKey) if err != nil { return []byte{}, err } // Marshal and provide it to bearer token user \tjsonData, err := btoken.MarshalJSON() return jsonData, er You can then send this to the intended recipient who can then use it\nUsing a Bearer Token To use a bearer token first you must convert it back into the BearerToken type.\nbtoken := new(token.BearerToken) err := btoken.UnmarshalJSON(jsonData) if err != nil { return btoken, err } //this is your bearer token you can now use \treturn btoken, err See Objects for further examples, but you can now attach Bearer Tokens to requests to NeoFS.\nThe recipient of the Bearer Token now provides both the bearer token and a generated session token as required.\nobject, err := cli.GetObject(ctx, getParams, client.WithBearer(btoken), client.WithSession(sessionToken)) In the examples on the objects page, there is no bearer token provided. This is because the client functions are expecting a variable length input, so just providing a Session Token is fine, you can also provide nil as the Bearer Token if you prefer\n"},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/acl-permissions/","title":"ACL Permissions","tags":[],"description":"","content":"NeoFS has an awesome set of permissions you can give to containers.\nACL stands for access control list - its a list, or table really, of rules. They are checked top to bottom to any incoming request. The first permission entry in the table that the request passes, will end the checks. To that end **it is important that all DENY permissions come after any ALLOW permissions.\nTypes of permission  Basic ACL Permisisons  These can only be applied to containers. They are the top most priority in terms of permissions, they cannot be changed, and they cannot be overruled. If the basic permissions of a container says that no one can read from the container, then no further permission can overrule this.   Extended ACL Permissions  These can be applied to a container at any time and can \u0026ldquo;extend\u0026rdquo; the permissions. For instance, you may have a container that is private, however you may want to give a specific wallet access to the container. Like a shared container (except the container owner pays for the container). These however, can also be given temporarily, instead of changing the permissions on the container as a whole. This way the permissions can be allowed to expire and remove any privileges that they offered. To do this, a Bearer Token is issued, and sent to the wallet that should gain these new access rights.    Basic ACL Permissions When creating a container, you are going to need to create a permission. There are multiple preset permissions you can see in the table further down\nGo Python C#  permissions := acl.EACLReadOnlyBasicRule   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     You can read more about ACL permissions within the NeoFS documentation however a set of available to use permissions are available. Most languages with an SDK will have constants set to these values\n In the following table, names that start with EACL (e.g EACLPrivateBasicRule) allow for extended policies to be used in conjunction with the basic ACL permissions\n    Name Value Description     PublicBasicRule 0x1FBFBFFF PublicBasicRule is a basic ACL value for final public-read-write container for which extended ACL CANNOT be set.   PrivateBasicRule 0x1C8C8CCC PrivateBasicRule is a basic ACL value for final private container for which extended ACL CANNOT be set.   ReadOnlyBasicRule 0x1FBF8CFF ReadOnlyBasicRule is a basic ACL value for final public-read container for which extended ACL CANNOT be set.   PublicAppendRule 0x1FBF9FFF PublicAppendRule is a basic ACL value for final public-append container for which extended ACL CANNOT be set.   EACLPublicBasicRule 0x0FBFBFFF EACLPublicBasicRule is a basic ACL value for non-final public-read-write container for which extended ACL CAN be set.   EACLPrivateBasicRule 0x0C8C8CCC EACLPrivateBasicRule is a basic ACL value for non-final private container for which extended ACL CAN be set.   EACLReadOnlyBasicRule 0x0FBF8CFF EACLReadOnlyBasicRule is a basic ACL value for non-final public-read container for which extended ACL CAN be set.   EACLPublicAppendRule 0x0FBF9FFF EACLPublicAppendRule is a basic ACL value for non-final public-append container for which extended ACL CAN be set.    Nice to Know: the ability for a basic ACL permission to allow for Extended ACL permissions is controlled by the highest \u0026lsquo;bit\u0026rsquo; in the above value. So comparing two of the above and comparing them in binary form\n   Name Value Binary     PublicBasicRule 0x1FBFBFFF 00011111101111111011111111111111   PrivateBasicRule 0x1C8C8CCC 00011100100011001000110011001100   EACLPublicAppendRule 0x0FBF9FFF 00001111101111111001111111111111    we can see here that the top two start 0001 however the final one starts 0000. When this is a 1, only BASIC ACL is processed.\nWhats important is that if Basic ACL denies access, then Extended ACL cannot overrule.\n Extended ACL Extended ACL permissions, are rules that can be applied over and beyond a container\u0026rsquo;s basic ACL permissions.\nThis is fantastically powerful as it allows a container owner to specify very strict and very specific rules to allow an account, or group of accounts to access certain objects within the container based on these extended rules.\nDue to the capabilities of Extended ACL, there are a few concepts to understand\nFour Concepts When thinking about these concepts, remember,\nWe are creating a rule for when an actor attempts to make a request to our container. These concepts are what make up that request\n Operation  The operation is a check against the type of request being made, e.g PUT, GET, HEAD, DELETE, SEARCH, RANGE, and RANGEHASH against the container   Target  The target (or targets) are the accounts making the requests to our container in the first place. Using targets, we can specify different groups of accounts that this rule should apply to. There are four ways to refer to groups of accounts.  user this is the container owner others this refers to everyone else system this refers to nodes on the NeoFS network. It\u0026rsquo;s less likely you will use this target Or a specific public key of an account   For each type of target, you can specify whether you want it to be included in the rule   Filters  Where these ACL rules can get really powerful is when they are combined with object attributes. Once you have read about object attributes you will know that when an object is uploaded to a container, attributes can be attached to it. These attributes can be searched/filtered as part of building up an ACL rule   Action  And finally the whole point of the rule in the first place - the action decides what the rule, if a match is made, either to ALLOW or DENY the request    Once you have this, the rule, containing these four parts, (which actually is a record) is added to an EACL table.\nImplementation We are going to create an Extended ACL rule that\n denys \u0026lsquo;any one else\u0026rsquo;, i.e all accounts that we don\u0026rsquo;t otherwise specify allows a specific account (public key) read access to the objects Requires the object to have an attribute LetMeIn:OK  Firstly we need two records. One for the others and one for our privileged key\nimport \u0026#34;github.com/nspcc-dev/neofs-sdk-go/eacl\u0026#34; othersRecord := eacl.NewRecord() privRecord := eacl.NewRecord() Operation Quite simple, set both records to apply to GET requests\nothersRecord.SetOperation(eacl.OperationGet) privRecord.SetOperation(eacl.OperationGet) Targets First we create a group that applies to the others target group - the rule that will block anyone we don\u0026rsquo;t want accessing our container. Then add it to the record\nothersTarget := eacl.NewTarget() othersTarget.SetRole(eacl.RoleOthers) // set the role to \u0026#39;others`  now create a target for a specific public key\n// demo public key - 33-byte hex encoded public key from N3 wallet const pubKeyStr = \u0026#34;03ab362a4eda62d22505ffe5a5e5422f1322317e8088afedb7c5029801e1ece806\u0026#34; pub := keys.NewPublicKeyFromString(pubKeyStr) privTarget := eacl.NewTarget() eacl.SetTargetECDSAKeys(privTarget, pub) Now we can add our targets to our record\nothersRecord.SetTargets(othersTarget) privRecord.SetTargets(privTarget) Filters Now we can use search capabilities against attributes on objects to filter even more specifically. In this case we are going to check that the object matches a specifc key, value pair\nothersRecord.AddObjectAttributeFilter(eacl.MatchStringEqual, \u0026#34;LetMeIn\u0026#34;, \u0026#34;OK\u0026#34;) privRecord.AddObjectAttributeFilter(eacl.MatchStringEqual, \u0026#34;LetMeIn\u0026#34;, \u0026#34;OK\u0026#34;) Now both records state that for anyone, even the privileged key, to GET a file, the attribute match.\nAction Now we specify what each record should do if any part of the rule matches. The first match will result in that request being allowed or denied depending on what record matched\nothersRecord.SetAction(eacl.ActionDeny) privRecord.SetAction(eacl.ActionAllow) EACL Table To use these records now, they need to go into a table that references the container that they should be applied to\nRemember to add the records ALLOW followed by DENY otherise all requests will match the first record (DENY) and no account will be able to access the container\n table := eacl.NewTable() table.SetCID(someContainerID) table.AddRecord(privRecord) table.AddRecord(othersRecord) Setting the EACL Container The first thing you can do is specify this against the whole container. This maybe something you would do if you were wanting to share the container\u0026rsquo;s contents with someone.\nYou will need\n a NeoFS client  _, err = cli.SetEACL(ctx, table) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t set extended ACL: %w\u0026#34;, err) } at this point setting the EACL against the container can take some time. Waiting is necessary to get a response.\nfor i := 0; i \u0026lt;= 30; i++ { if i == 30 { log.Fatal(\u0026#34;timeout, extended ACL was not persisted in side chain\u0026#34;) } time.Sleep(time.Second) _, err := cli.EACL(ctx, someContainerID) if err != nil { return fmt.Errorf(\u0026#34;error setting eacl: %w\u0026#34;, err) } } Of course this can be handled better with channels\nBearer Token There is more on Bearer Tokens here, however you can add these Extended ACL rules to them so that the account that is issued with the token, can access objects within the container based on the Extended ACL rules.\nTo create a bearer token, you will need the private key of the container owner (containerOwnerKey).\nThis is further explained in Bearer Tokens\nbtoken := new(token.BearerToken) btoken.SetOwner(tokenReceiverID) btoken.SetLifetime(100, 10, 1) // exp, nbf, iat arguments just like in JWT tokens. You can calculate the expiry using the current epoch and a number of epochs into the future btoken.SetEACLTable(table) //table from earlier  err := btoken.SignToken(containerOwnerKey) if err != nil { return fmt.Errorf(\u0026#34;error signing token: %w\u0026#34;, err) } tokenBytes, err := btoken.MarshalJSON() if err != nil { return fmt.Errorf(\u0026#34;error marshaling token: %w\u0026#34;, err) } You can then issue the tokenBytes to whichever account should have it. See Bearer Tokens for more information\n"},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/clients/","title":"Clients","tags":[],"description":"","content":"There are two types of client to be aware, of and as they are both clients, it can be confusing. You have a wallet client and an NeoFS client. Interactions with NeoFS will require a NeoFS client, whereas wallet actions will require a wallet client. Note they do not reside in the same package\nWallet Client When using a wallet client you will need to import\nGo Python C#  import ( \u0026#34;github.com/nspcc-dev/neo-go/pkg/rpc/client\u0026#34; \u0026#34;github.com/nspcc-dev/neo-go/pkg/wallet\u0026#34;\t)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     To create a wallet client\nGo Python C#  ctx := context.Background() // use endpoint addresses of public RPC nodes, e.g. from https://dora.coz.io/monitor cli, err := client.New(ctx, \u0026#34;http://seed1t4.neo.org:20332\u0026#34;, client.Options{}) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create client: %w\u0026#34;, err) }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     NeoFS Client The client wraps around the raw API requests to NeoFS. Once you have a client requests to NeoFS can be made so you will need to make this early on from the wallet/private key.\nWhen using the NeoFS client you will import\nGo Python C#  import ( \u0026#34;github.com/nspcc-dev/neofs-sdk-go/client\u0026#34; )   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Creating a client can be done like so\nGo Python C#  cli, err := client.New( // provide private key associated with request owner  client.WithDefaultPrivateKey(privateKey), // find endpoints in https://testcdn.fs.neo.org/doc/integrations/endpoints/  client.WithURIAddress(TESTNET, nil), // check client errors in go compatible way  client.WithNeoFSErrorParsing(), ) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create client: %w\u0026#34;, err) }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);      Private key can be retrieved from a wallet - its type is *ecdsa.PrivateKey The network is a string, for now you can use  Go Python C#  TESTNET string = \u0026#34;grpcs://st01.testnet.fs.neo.org:8082\u0026#34; MAINNET = \u0026#34;grpcs://st01.testnet.fs.neo.org:8082\u0026#34;   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/policies/","title":"Policies","tags":[],"description":"","content":"Before we can create a container, we need to define the policy. A policy defines which storage nodes on NeoFS you are happy to store your data on.\n\u0026ndash; todo, how do policies get defined?\nBasic example\nGo Python C#  const placementPolicy = `REP 2 IN X CBF 2 SELECT 2 FROM * AS X `   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/wallets/","title":"Wallets","tags":[],"description":"","content":"Almost everything you may want to do with NeoFS will require access to a wallet. Here are a few handy ways to get a wallet\nImports Go Python C#  import ( \u0026#34;github.com/nspcc-dev/neo-go/pkg/rpc/client\u0026#34; \u0026#34;github.com/nspcc-dev/neo-go/pkg/wallet\u0026#34;\t)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Retrieve from a NEP-6 file (json format) Go Python C#  w, err := wallet.NewWalletFromFile(path) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t read the wallet: %w\u0026#34;, err) }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Create a new wallet This wallet has no password but is the simplest form of wallet that you can generate\nGo Python C#  acc, err := wallet.NewAccount() //generates a new private key if err != nil { return \u0026amp;wallet.Wallet{}, err } w, err := wallet.NewWallet(path) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create the wallet: %w\u0026#34;, err) } w.AddAccount(acc)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     A slighty more secure wallet\u0026hellip; with a password Go Python C#  w, err := wallet.NewWallet(path) w.CreateAccount(name, password) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create the wallet: %w\u0026#34;, err) }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Retrieving the private key from a wallet Sometimes for specific actions you will need the private key of the wallet. If you have the password you can extract the private key\nNotice this decrypts the wallet. At this point the wallet is considered \u0026ldquo;unlocked\u0026rdquo;. Sometimes you may find you are performing an action on a walelt and the error is it is locked. The result of decrypting is unlocking the wallet.\nGo Python C#  addr := w.GetChangeAddress() //get the default wallet acc := w.GetAccount(addr) if acc == nil { return nil, fmt.Errorf(\u0026#34;invalid wallet address %s: %w\u0026#34;, addrStr, err) } if err := acc.Decrypt(password, keys.NEP2ScryptParams()); err != nil { return nil, errors.New(\u0026#34;[decrypt] invalid password - \u0026#34; + err.Error()) } privateKey := \u0026amp;acc.PrivateKey().PrivateKey   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Retrieving wallet balances Often you will want to know the balances on a wallet. There is a potential minor confusion at this stage. Neo N3 wallets store NEP-17 coins. Both Neo and Gas are NEP 17 currencies, however any currency you or someone else may make could also be a NEP-17 currency. There are other standards such as NEP-11 and the difference I will leave to you to read about.\nHowever, NeoFS has a smart contract in which you need to transfer Gas to, so that you can pay for NeoFS storage space. This balance won\u0026rsquo;t show up in your wallet balance.\nTo retrieve you wallet\u0026rsquo;s NEP-17 balances you will need to create a wallet client.\nYou will need\n A wallet address you want to get the balances of  Go Python C#  cli, err := client.New(ctx, \u0026#34;http://seed1t4.neo.org:20332\u0026#34;, client.Options{}) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t create the client: %w\u0026#34;, err) } err = cli.Init() if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t init the client: %w\u0026#34;, err) } recipient, err := helper.StringToUint160(walletAddress) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t convert the wallet address: %w\u0026#34;, err) } balances, err := cli.GetNEP17Balances(recipient) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t retrieve the balances: %w\u0026#34;, err) } fmt.Printf(\u0026#34;balances %+v\\r\\n\u0026#34;, balances)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Transferring NEP-17 tokens A major part of blockchain technology is to be able to transfer tokens to other wallets (including sending GAS to the NeoFS smart contract).\nYou will need\n An unlocked wallet myWallet A wallet to send Nep17 to walletTo The amount you would like to send (as an int64 - no decimals in blockchain remember!) The token you would like to send. To retrieve the token, you need the token name to get the contract hash  Go Python C#  gasToken, err := cli.GetNativeContractHash(nativenames.Gas) if err != nil { log.Fatal(err) }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     then\nGo Python C#  ctx := context.Background() // use endpoint addresses of public RPC nodes, e.g. from https://dora.coz.io/monitor cli, err := client.New(ctx, \u0026#34;http://seed1t4.neo.org:20332\u0026#34;, client.Options{}) if err != nil { return util.Uint256{}, err } err = cli.Init() if err != nil { return util.Uint256{}, err } recipient, err := helper.StringToUint160(walletTo) if err != nil { return util.Uint256{}, err } txHash, err := cli.TransferNEP17(myWallet, recipient, gasToken, amount, 0, nil, nil) le := txHash.StringLE() return txHash, err   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     the txHash is reversed in its uint256 state. You need to reverse it so that it matches the txHashes you would find in a blockchain explorer for instance, hence the le := txHash.StringLE()\n NeoFS Balance However this balance as I mentioned, does not include your NeoFS balance. For that you need a NeoFS client\nGo Python C#  import ( \u0026#34;github.com/nspcc-dev/neofs-sdk-go/client\u0026#34; )   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Once you have this, you can now retrieve your NeoFS balance\nYou will need\n Private key NeoFS client (cli)  Go Python C#  w, err := owner.NEO3WalletFromPublicKey(\u0026amp;key.PublicKey) if err != nil { fmt.Errorf(\u0026#34;couldn\u0026#39;t create wallet from public key: %w\u0026#34;, err) } id := owner.NewIDFromNeo3Wallet(w) ctx := context.Background() neoFSBalance, err := cli.GetBalance(ctx, id) fmt.Printf(\u0026#34;neofs balance %+v\\r\\n\u0026#34;, neoFSBalance)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     "},{"uri":"https://amlwwalker.github.io/neo-docs/introduction/libraries/","title":"Libraries","tags":[],"description":"","content":"Code Libraries The Go SDK is the basis of all the functionality that is available to you as a developer with regards to NeoFS.\nthe Neo-Go package offers all the functionalities that you will require to interact with the Neo blockchain and wallets\nSDK The SDK is responsible for providing functionality to interact with NeoFS itself via gRPC requests. You will need the SDK for such things as:\n creating, retrieving, deleting containers creating, updating, retrieving, deleting objects creating basic and extended ACL rules for containers  find it here Neo-Go library General interaction with NeoFS doesn\u0026rsquo;t require Neo-Go however invariably you will need to manage wallets or use cryptographic functions that are required while setting permissions throughout the NeoFS system.\nfind it here Helpers Sometimes there will be throughout the tutorials the need to reuse functions from elsewhere. These are stored in the Helpers tutorial and will be useful functions to have available within your projects\nSee Helpers, whenever you see helper. in a code sample\n Neo FS local environment You can clone the repository so that you can start NeoFS locally, this may be beneficial for education reasons or perhaps to run integration tests against a local NeoFS\nhttps://github.com/nspcc-dev/neofs-dev-env/\nResources  Javascript interaction with NeoFS - https://github.com/CityOfZion/neofs-demo/blob/461466ab5450f4defa75c12e81a095b2b1411e0d/src/neofs.js#L167 Smart contract interaction in Go - https://github.com/nspcc-dev/neo-go/blob/f9e8dcbed8c9325983403f25a1a37e764523ff62/cli/smartcontract/smart_contract.go#L574 Transaction documentation in Go - https://pkg.go.dev/github.com/nspcc-dev/neo-go@v0.94.1-pre/pkg/core/transaction neo-go low level docs - https://github.com/nspcc-dev/neo-go/tree/master/docs gRPC neofs docs - https://github.com/nspcc-dev/neofs-api/tree/master/proto-docs storage/placement policy low level docs - https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/02-policy.md ACL low level docs - https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/07-acl.md  "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/containers/","title":"Containers","tags":[],"description":"","content":"Containers manage the permissions/access of a group of objects that are being stored. Before being able to store an object, you need to create a container.\nCreating a container Before being able to create a container, you will need to\n create a policy (placementPolicy) have access to a private key. This is retrieved from a json file using the helper function helper.GetCredentialsFromPath (key) Decide on a set of permissions, (permissions) Have created a NeoFS client (cli)  Owner ID Before continuing, you will need to get the owner ID from the wallet private key. The owner ID is not the same as the wallet ID or public key. A straight forward way to do this is\nGo Python C#  //see key retrieval generation for how to get a key w, err := owner.NEO3WalletFromPublicKey(\u0026amp;key.PublicKey) if err != nil { return fmt.Errorf(\u0026#34;invalid private key\u0026#34;) } ownerID := owner.NewIDFromNeo3Wallet(w)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Creating a container Now we can get on with creating a container.\nYou will need\n A container placement policy (placementPolicy) A set of Basic ACL permissions (permissions)  Go Python C#  containerPolicy, err := policy.Parse(placementPolicy) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t parse placement policy: %w\u0026#34;, err) } cnr := container.New( // container policy defines the way objects will be  // placed among storage nodes from the network map  container.WithPolicy(containerPolicy), // container owner can set BasicACL and remove container  container.WithOwnerID(ownerID), // read more about basic ACL in specification:  // https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/07-acl.md  container.WithCustomBasicACL(permissions), // Attributes are key:value string pairs they are always optional  container.WithAttribute( container.AttributeTimestamp, strconv.FormatInt(time.Now().Unix(), 10), ),   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Finally we can put the container on NeoFS. We will receive a response that contains the container\u0026rsquo;s ID.\nGo Python C#  response, err := cli.PutContainer(ctx, cnr) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t put container: %w\u0026#34;, err) } fmt.Println(response.ID())   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Listing Containers You can list all the containers owned by a wallet. This will return an array of container IDs\nGo Python C#  response, err := cli.ListContainers(ctx, wallet.OwnerIDFromPrivateKey(key)) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t list container: %w\u0026#34;, err) } walletList := response.IDList()   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Retrieve a Container You can retrieve a container once you have the ID\nGo Python C#  response, err := cli.GetContainer(ctx, containerID) if err != nil { return fmt.Errorf(\u0026#34;can\u0026#39;t get container %s: %w\u0026#34;, containerID, err) } contianeer := response.Container()   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     From a container, you can find out storage policies, owners and any other meta information about the container itself\nDeleting Containers Once you have created a container, you will receive the ID of the container as part of the response (see above). Using this ID you can now delete the container with ease\nGo Python C#  response, err := cli.DeleteContainer(ctx, containerID) if err != nil { return nil, fmt.Errorf(\u0026#34;can\u0026#39;t get container %s: %w\u0026#34;, containerID, err) } fmt.Printf(\u0026#34;deletion response %+v\\r\\n\u0026#34;, response)   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Questions about containers  if you delete a container what happens to all the objects within a container using multisig wallets, could two or more people share ownership of a container - no. status - what information do I receive from a status - error on failure.  "},{"uri":"https://amlwwalker.github.io/neo-docs/tutorials/helpers/","title":"Helpers","tags":[],"description":"","content":"There are some functions that don\u0026rsquo;t quite fit into another topic. They will be referenced as helper.X in other tutorials\nRetrieving the Owner ID If you have the public key of a wallet you can determine the ownerID\nw, err := owner.NEO3WalletFromPublicKey(\u0026amp;publicKey) if err != nil { return fmt.Errorf(\u0026#34;error retreiving wallet %w\u0026#34;, err) } id, err := owner.NewIDFromNeo3Wallet(w) Convert String to Uin160 Convert a string format Neo (3) address into a uint160. This is the format required for making transfers\nGo Python C#  // StringToUint160 attempts to decode the given NEO address string // into an Uint160. const NEO3Prefix byte = 0x35 func StringToUint160(s string) (u util.Uint160, err error) { b, err := base58.CheckDecode(s) if err != nil { return u, err } if b[0] != NEO3Prefix { return u, errors.New(\u0026#34;wrong address prefix\u0026#34;) } return util.Uint160DecodeBytesBE(b[1:21]) }   print(\u0026#34;please help by opening an MR and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening an MR and filling in these code snippets!\u0026#34;);     Get credentials from path This returns the private key, which anything can be derived from, with regards to a wallet Go Python C#  // GetCredentialsFromPath retrieves the private key from a wallet file func GetCredentialsFromPath(path, address, password string) (*ecdsa.PrivateKey, error) { w, err := wallet.NewWalletFromFile(path) if err != nil { return nil, fmt.Errorf(\u0026#34;can\u0026#39;t read the wallet: %walletPath\u0026#34;, err) } var ( err error ) addr := w.GetChangeAddress() //default address  acc := w.GetAccount(addr) if acc == nil { return nil, fmt.Errorf(\u0026#34;invalid wallet address %s: %w\u0026#34;, addrStr, err) } if err := acc.Decrypt(password, keys.NEP2ScryptParams()); err != nil { return nil, errors.New(\u0026#34;[decrypt] invalid password - \u0026#34; + err.Error()) } return \u0026amp;acc.PrivateKey().PrivateKey, nil }   print(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;)   Console.WriteLine(\u0026#34;please help by opening a Pull Request and filling in these code snippets!\u0026#34;);     Calculate Epochs This is a very simple estimation of calculating the total amount of epochs at at some point in the future\nfunc CalculateEpochsForTime(currentEpoch uint64, durationInSeconds , msPerEpoch int64) uint64 { durationInEpochs := durationInSeconds/(msPerEpoch/1000) //in seconds \treturn currentEpoch + uint64(durationInEpochs) // (estimate) } "},{"uri":"https://amlwwalker.github.io/neo-docs/introduction/concepts/","title":"Concepts","tags":[],"description":"","content":"NeoFS is very carefully designed to offer the power of a filesytem with all the expected capabilities, on top of a decentralised network.\nThis means that files/folders etc can have permissions to who can read/write to them who can delete etc etc.\nAs NeoFS is built on top of the Neo blockchain, these permissions are based on wallet addresses of users.\nObjects Objects represent all files/data that is stored on NeoFS. Objects are accessed via SessionTokens or Bearer Tokens\nContainers A container controls the basic permissions that are applied to all content within it. Think of a container like a drive on a computer or network (and not a folder per se).\nAll objects must live within a container, their permissions will default to the permissions of the container\nOwnerID OwnerID is derived from the private key of a wallet and is unique to that wallet.\nPolicies Container policies define the way objects will be placed among storage nodes. That is, you as the container owner can decide what type of Node should store a file for you.\nEACL Containers and sessions/bearer tokens can have differeing permissions. By default permissions will be the same as the container\u0026rsquo;s however if permissions are sent as part of a request, then they can override the permissions of the container\nRead more about ACL here\nAccess Access is made using session tokens (derived from the private key), or bearer tokens, which are distributed by the container owner to others they want to be able to offer restricted capabilities (and time limits) to other users\nWallets A wallet is specifically an item that takes the NEP-6 format and contains any number of accounts. Accounts contain a public address, a private key and other information (read more here)\nWallets contain accounts. The first account in a wallet is the default and its wallet Address is the default address\n"},{"uri":"https://amlwwalker.github.io/neo-docs/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://amlwwalker.github.io/neo-docs/tags/","title":"Tags","tags":[],"description":"","content":""}]